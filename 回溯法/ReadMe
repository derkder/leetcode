用于："所有可能的解"
因为每一次return都只会退出一层递归
所以不是要求所有的解这样算很浪费，很容易测试用例有超出来的

//感觉回溯法很慢，大多数一下子能想到回溯法的一般有更好的方式代替（dp、贪心等），所以感觉除了求全部解不要用回溯


先画出树图//！！！
再套模板（这个return void的模板没那么常见，一些题里139return bool的比较常见）
public void backtracking (此时已经走完的路径startIndex，此次可选择的选择列表n,终止条件){//！！！！！
    if(判断出口的条件){
        存放结果;（结果大概是个全局变量）
        return;//递归的最深度，即终止
       }
    for(int i=();i<选择列表长度;i++){//列表长度是所有的选择长度
     处理节点;//！！！！！！！
     backtracking(此时已经走完的路径startIndex，此时的选择列表,终止条件)//此时列表是下一节点的列表
     撤销上一步的路径;//！！！！！！！，不一定有
    }
   }
}
public bool backtracking (此时已经走完的路径startIndex，此次可选择的选择列表n,终止条件){//！！！！！
    if(判断出口的条件){
        return true;//递归的最深度，即终止
       }
    for(int i=();i<选择列表长度;i++){//列表长度是所有的选择长度
     处理节点;//！！！！！！！
     if(符合要求&&backtracking(此时已经走完的路径startIndex，此时的选择列表,终止条件)) return true;
     撤销上一步的路径;//！！！！！！！，不一定有
     return false;
    }
   }
}





细节：
1、    优化：记忆化回溯（139单词拆分）
       加memory数组记录
2、    判断是否需要剪枝：
       从递归树中看到，路径没有重复的，也没有不符合条件的，所以不需要剪枝
       剪枝的位置：处理节点之前（其实就是处理节点的第一部分）


超级链接:https://leetcode.cn/problems/subsets/solution/c-zong-jie-liao-hui-su-wen-ti-lei-xing-dai-ni-gao-/

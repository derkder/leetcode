## 运用情况与例外
用于："所有可能的解(且列出)"，**但也有例外：** 不同路径 II  
```
何时使用【回溯】，何时使用【动态规划】，用大白话说，就是：
首先看**取值范围**，递归回溯一维数组，100就是深度的极限了（何况本题是100*2）
如果是求走迷宫的【路径】，必然是回溯；如果是走迷宫的【路径的条数】，必然是dp--------
```            
因为每一次return都只会退出一层递归  
所以不是要求所有的解这样算很浪费，很容易测试用例有超出来的  
  
//感觉回溯法很慢，大多数一下子能想到回溯法的一般有更好的方式代替（dp、贪心等），所以感觉除了求全部解不要用回溯  

---

## 模板
先画出树图//！！！  
再套模板（这个return void的模板没那么常见，一些题里139return bool的比较常见）  
```
public void backtracking (此时已经走完的路径startIndex，此次可选择的选择列表n,终止条件){//！！！！！也不一定是startindex而是记录used
    if(判断出口的条件){
        存放结果;（结果大概是个全局变量）
        return;//递归的最深度，即终止
       }
    for(int i=();i<选择列表长度;i++){//列表长度是所有的选择长度
     处理节点;//！！！！！！！
     backtracking(此时已经走完的路径startIndex，此时的选择列表,终止条件)//此时列表是下一节点的列表
     撤销上一步的路径;//！！！！！！！，不一定有
    }
   }
}
```
```
public bool backtracking (此时已经走完的路径startIndex，此次可选择的选择列表n,终止条件){//！！！！！
    if(判断出口的条件){
        return true;//递归的最深度，即终止
       }
    for(int i=();i<选择列表长度;i++){//列表长度是所有的选择长度
     处理节点;//！！！！！！！
     if(符合要求&&backtracking(此时已经走完的路径startIndex，此时的选择列表,终止条件)) return true;
     撤销上一步的路径;//！！！！！！！，不一定有
     return false;
    }
   }
}
```

---


## 细节：  
1、    优化：记忆化回溯（139单词拆分）  
       加memory数组记录  
2、    判断是否需要剪枝（continue即跳过这轮循环）：  
       从递归树中看到，路径没有重复的，也没有不符合条件的，所以不需要剪枝  
       剪枝的位置：处理节点之前（其实就是处理节点的第一部分）  

  
超级链接:[https://leetcode.cn/problems/subsets/solution/c-zong-jie-liao-hui-su-wen-ti-lei-xing-dai-ni-gao-/]

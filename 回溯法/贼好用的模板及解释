回溯算法
思路讲解
回溯概念介绍：
回溯法是一种选优搜索法，按选优条件向前搜索，以达到目标。但当探索到某一步时，发现原先选择并不优或达不到目标，就退回一步重新选择，这种走不通就退回再走的技术为回溯法。

回溯和递归的区别：
用一个比较通俗的说法来解释递归和回溯：
我们在路上走着，前面是一个多岔路口，因为我们并不知道应该走哪条路，所以我们需要尝试。尝试的过程就是一个函数。
我们选择了一个方向，后来发现又有一个多岔路口，这时候又需要进行一次选择。所以我们需要在上一次尝试结果的基础上，再做一次尝试，即在函数内部再调用一次函数，这就是递归的过程。
这样重复了若干次之后，发现这次选择的这条路走不通，这时候我们知道我们上一个路口选错了，所以我们要回到上一个路口重新选择其他路，这就是回溯的思想。

回溯算法的效率：
回溯算法的本质是通过穷举进行暴力搜索，选择我们需要的答案。

什么情况选择回溯算法：
有一些问题需要遍历所有情况才能解决，且没有好的办法的时候使用回溯算法。

回溯算法解决的问题：
组合问题：N个数里面按一定规则找出k个数的集合
切割问题：一个字符串按一定规则有几种切割方式
子集问题：一个N个数的集合里有多少符合条件的子集
排列问题：N个数按一定规则全排列，有几种排列方式
棋盘问题：N皇后，解数独等等

解决回溯算法：
回溯算法对应的问题都可以抽象为树形结构，因为回溯法解决的都是集合中递归查找子集，集合的大小就构成树的宽度，递归的深度构成了树的深度
递归的出口就决定的树的高度
代码模板//！！！！！！！
public void backtrcking (此时已经走完的路径startIndex，此次可选择的选择列表n,终止条件){//！！！！！
    if(判断出口的条件){
        存放结果;
        return;//递归的最深度，即终止
        for(int i=();i<选择列表长度;i++){//列表长度是所有的选择长度
         处理节点;//！！！！！！！
         backtracking(此时已经走完的路径startIndex，此时的选择列表,终止条件)//此时列表是下一节点的列表
         撤销上一步的路径;//！！！！！！！
        }
    }
}
1



例题：
给定两个整数 n 和 k，返回范围 [1, n] 中所有可能的 k 个数的组合。
你可以按 任何顺序 返回答案。
该题是组合问题：
class Solution {
  List<List<Integer>> lists = new ArrayList<>();
    List<Integer> list=new ArrayList<>(); 
    public List<List<Integer>> combine(int n, int k) {
        backtrcking(n,k,0);
        return lists;
    }
    public void backtrcking(int n ,int k ,int startIndex){
        if(list.size()==k){
            lists.add(new ArrayList<Integer>(list));
            return;
        }
        for(int i = startIndex+1;i<=n;i++){
            list.add(i);
            backtrcking(n,k,i);//这里传进来的是i，是为了防止重复组合例如[1,1] 、[1,2]和[2,1]
            list.remove(list.size()-1);
        }
    }
}

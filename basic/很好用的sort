剑指 Offer II 033. 变位词组

排序完之后还是个str
unordered_map<string, vector<string>> mp;
for (string& str: strs) {
            string key = str;
            sort(key.begin(), key.end());
            mp[key].emplace_back(str);
        }

附加：遍历：
 vector<vector<string>> ans;
        for (auto it = mp.begin(); it != mp.end(); ++it) {
            ans.emplace_back(it->second);
        }


sort甚至可以给vector<vector<int>>排序，会按照小vector的第一个值来排序



它使用的排序方法是类似于快排的方法，时间复杂度为n*log2(n)
Sort函数有三个参数：
（1）第一个是要排序的数组的起始地址。
（2）第二个是结束的地址（最后一位要排序的地址）
（3）第三个参数是排序的方法，可以是从大到小也可是从小到大，还可以不写第三个参数，此时默认的排序方法是从小到大排序。


Sortt函数的第三个参数可以用这样的语句告诉程序你所采用的排序原则
less<数据类型>()//从小到大排序!!!!!
greater<数据类型>()//从大到小排序!!!!!!
//感觉和堆反过来的，堆的greater最小的在上面，是小根堆
#include<iostream>
#include<algorithm>
using namespace std;
 int main() 
{ 
 char a[11]="asdfghjklk";
 for(int i=0;i<10;i++)
 cout<<a[i]<<endl;
 sort(a,a+10,greater<char>());
 for(int i=0;i<10;i++)
 cout<<a[i]<<endl;
 return 0;
}
#include<iostream>
#include<algorithm>
using namespace std;

int main(){
int num[10] = {6,5,9,1,2,8,7,3,4,0};
sort(num,num+10,greater<int>());
for(int i=0;i<10;i++){
            cout<<num[i]<<" ";
}//输出结果:9 8 7 6 5 4 3 2 1 0

return 0;
	
} 





自定义sort排序
https://blog.csdn.net/weixin_44713619/article/details/108718416
static bool compare(vector<int>&a,vector<int>&b)
{
    return a[1]<b[1];		//a[num]<b[num],num代表指定列
    						// < 代表升序排列
}
sort(intervals.begin(),intervals.end(),compare);//intervals为二维vector容器
#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

static bool compare(vector<int> &a, vector<int> &b) {
    return a[1] < b[1];
}

int main() {
    vector<vector<int>> intervals = {{1, 2},
                                     {2, 1},
                                     {1, 6},
                                     {1, 3}};
    cout << "排序前：" << endl;
    for (const auto &item:intervals) {
        for (auto item1:item) {
            cout << item1 << "\t";
        }
        cout << endl;
    }
    sort(intervals.begin(), intervals.end(), compare);
    cout << "排序后：" << endl;
    for (const auto &item:intervals) {
        for (auto item1:item) {
            cout << item1 << "\t";
        }
        cout << endl;
    }
}


